# Vert.x-in-Action-ChineseVersion
Vert.x-in-Action的中文翻译版.
第Ⅰ部分  基于Vert.x的异步编程基本原理
章  Vert.x、异步编程和反应式系统 3
1.1  分布式和网络化是常态 3
1.2  我们不是在孤岛上生活 4
1.3  网络上没有免费的午餐 5
1.4  简洁的阻塞式API 5
1.5  阻塞式API浪费了资源，增加了成本 7
1.6  基于非阻塞I/O的异步
编程 9
1.7  事件驱动的多路复用：事件循环 12
1.8  什么是反应式系统 15
1.9  反应式还有哪些含义 16
1.10  什么是Vert.x 17
1.11  你的Di一个Vert.x应用  程序 18
1.11.1  准备项目 18
1.11.2  VertxEcho类 19
1.11.3  回调函数的角色 21
1.11.4  它是反应式的吗 22
1.12  Vert.x的替代品 23
1.13  本章小结 25
第2章  Verticle：Vert.x的基本处理单元 27
2.1  编写一个Verticle 27
2.1.1  准备项目 28
2.1.2  实现Verticle类 29
2.1.3  运行并初次观察 30
2.2  关于Verticle的更多细节 32
2.2.1  阻塞与事件循环 32
2.2.2  生命周期事件的异步通知 33
2.2.3  部署Verticle 35
2.2.4  传递配置参数 38
2.3  当代码需要阻塞时 39
2.3.1  Worker Verticle 39
2.3.2  executeBlocking方法 40
2.4  Verticle中到底有什么 42
2.4.1  Verticle及其环境 42
2.4.2  关于Verticle Context的更多细节 43
2.4.3  桥接Vert.x线程和非Vert.x线程 45
2.5  本章小结 46
第3章  事件总线：Vert.x应用程序的骨干 47
3.1  什么是事件总线 47
3.1.1  事件总线是不是另一种消息代理 48
3.1.2  “点对点”模式 49
3.1.3  “请求-应答”模式 49
3.1.4  “发布-订阅”模式 50
3.2  事件总线的示例 51
3.2.1  温度传感器Verticle 52
3.2.2  监听器Verticle 53
3.2.3  传感器数据Verticle 54
3.2.4  HTTP服务器Verticle 54
3.2.5  启动应用程序 58
3.3  集群化和分布式的事件总线 59
3.3.1  Vert.x中的集群 59
3.3.2  从事件总线到分布式事件总线 60
3.4  本章小结 63
第4章  异步数据和事件流 65
4.1  统一的流模型 65
4.2  什么是背压 68
4.3  开发一个音乐流点唱机 70
4.3.1  功能与用法 71
4.3.2  HTTP处理：宏观视图 73
4.3.3  点唱机Verticle的基础 73
4.3.4  传入的HTTP连接 75
4.3.5  尽可能地下载 76
4.3.6  读取MP3文件，但不能太快 77
4.4  解析简单的流 81
4.5  解析复杂的流 83
4.6  关于流获取模式的简短说明 86
4.7  本章小结 88
第5章  回调以外的异步编程模型 89
5.1  构建异步操作：一个边缘服务的示例 89
5.1.1  应用场景 90
5.1.2  温度传感器Verticle 91
5.1.3  快照服务Verticle 92
5.2  回调 93
5.2.1  实现 93
5.2.2  运行 95
5.2.3  “回调地狱”不是根本问题 96
5.3  Future和Promise 98
5.3.1  Vert.x中的Future和Promise 98
5.3.2  Vert.x 4中基于Future的API 100
5.3.3  与CompletionStage API的互操作 100
5.3.4  使用Vert.x Future特性实现的Collector 
Service 102
5.4  反应式扩展 103
5.4.1  RxJava的简要说明 104
5.4.2  RxJava与Vert.x 107
5.4.3  用RxJava实现的CollectorService 108
5.5  Kotlin协程 111
5.5.1  什么是协程 111
5.5.2  Vert.x与Kotlin的协程 112
5.5.3  使用协程实现边缘服务 113
5.6  究竟应该用哪一种模型 115
5.7  本章小结 116
第6章  不只是事件总线 117
6.1  用服务API重新实现温度传感器 117
6.2  RPC的回归 118
6.3  定义服务接口 119
6.4  服务的实现 121
6.5  启用Proxy代码自动生成 122
6.6  部署事件总线服务 122
6.7  回调之外的服务代理 123
6.8  Vert.x中的测试 125
6.8.1  在Vert.x中使用JUnit 5 125
6.8.2  测试DataVerticle 126
6.8.3  运行测试 129
6.9  本章小结 129
第Ⅱ部分  用Vert.x开发反应式服务
第7章  设计一个反应式应用程序 133
7.1  反应式应用程序的必要条件 133
7.2  “一万步挑战” 134
7.3  一个应用程序，多个服务 137
7.4  服务规范 139
7.4.1  用户资料服务 139
7.4.2  数据收集服务 140
7.4.3  用户活动服务 141
7.4.4  对外接口服务 143
7.4.5  用户Web应用程序 144
7.4.6  事件统计服务 145
7.4.7  贺信服务 146
7.4.8  公告牌Web应用程序 146
7.5  运行应用程序 147
7.6  本章小结 149
第8章  Web技术栈 151
8.1  实现对外接口服务 152
8.1.1  路由HTTP请求 152
8.1.2  发起HTTP请求 154
8.2  用JWT令牌进行访问控制 156
8.2.1  使用JWT令牌 156
8.2.2  JWT令牌中有
什么 158
8.2.3  用Vert.x处理JWT令牌 159
8.2.4  用Vert.x签发JWT令牌 161
8.3  跨域资源共享(CORS) 162
8.3.1  问题在哪里 162
8.3.2  在Vert.x中支持CORS 164
8.4  一个现代化的Web前端 165
8.4.1  Vue.js 165
8.4.2  Vue.js应用程序结构及构建集成 166
8.4.3  后端集成的效果演示 168
8.4.4  在Vert.x中服务静态内容 170
8.5  编写集成测试 171
8.6  本章小结 175
第9章  Vert.x中的消息机制与事件流 177
9.1  用Vert.x实现基于事件驱动的服务 177
9.1.1  Vert.x为我们提供了什么 178
9.1.2  我们会用到的中间件和服务 179
9.1.3  AMQP和Message Broker简介 179
9.1.4  Kafka简介 180
9.2  通过HTTP和AMQP
可靠地接收消息 181
9.2.1  从AMQP接收数据 181
9.2.2  将AMQP消息转换成Kafka记录 183
9.2.3  从HTTP接收数据 185
9.3  发送贺信 186
9.3.1  监听每日步数变化 187
9.3.2  发送邮件 188
9.4  集成测试 190
9.4.1  测试收取功能 190
9.4.2  测试贺信功能 193
9.5  本章小结 196
0章  用数据库进行持久化状态管理 197
10.1  数据库与Vert.x 197
10.1.1  Eclipse Vert.x支持的数据库客户端 198
10.1.2  数据对象映射并非必需 199
10.2  使用MongoDB的用户资料服务 200
10.2.1  数据模型 200
10.2.2  用户资料API Verticle及其初始化 201
10.2.3  校验用户输入 202
10.2.4  在MongoDB中添加用户 203
10.2.5  用户的认证 206
10.2.6  获取用户数据 207
10.2.7  更新用户数据 208
10.3  使用PostgreSQL的用户活动服务 209
10.3.1  服务的数据模型 209
10.3.2  打开一个连接池 210
10.3.3  设备更新事件的生命周期 210
10.3.4  插入新记录 211
10.3.5  生成设备的每日运动更新 213
10.3.6  用户活动服务的查询接口 214
10.4  集成测试 215
10.4.1  测试用户资料服务 215
10.4.2  测试用户活动服务接口 218
10.4.3  测试用户活动服务的事件处理 219
10.5  本章小结 222
1章  端到端的实时反应式事件处理 223
11.1  使用Kafka和RxJava实现的流式数据处理 223
11.1.1  生成用户当天步数更新 224
11.1.2  计算数据收集服务的吞吐量 226
11.1.3  计算各城市的数据趋势 227
11.2  实时的反应式Web应用  程序 229
11.2.1  将Kafka消息转发至Vert.x事件总线 230
11.2.2  桥接事件总线和Web应用程序 231
11.2.3  Web应用程序基于Kafka消息的实时更新 233
11.3  流与状态 235
11.3.1  数据更新流 235
11.3.2  排名数据的shui合阶段 235
11.3.3  根据消息流周期性地更新排名 237
11.4  本章小结 240
2章  通过负载测试和混沌测试提升系统响应能力 241
12.1  初始实验：系统的性能  好吗 242
12.1.1  负载测试前的一些考量 242
12.1.2  用Locust模拟用户 243
12.1.3  用Hey进行负载测试 246
12.2  混沌测试 250
12.2.1  测试方案 250
12.2.2  用Pumba进行混沌测试 251
12.2.3  系统尚不具备回弹性 253
12.3  从“可扩展性”到“可扩展
  性 回弹性” 254
12.3.1  强制Chao时 254
12.3.2  使用断路器 256
12.3.3  回弹性与后备策略 260
12.4  本章小结 264
3章  容器原生的Vert.x 265
13.1  云环境里的温度传感器 266
13.1.1  温度传感器服务 267
13.1.2  传感器网关 268
13.1.3  Heat API 269
13.1.4  部署本地集群 271
13.2  让服务运行在  Kubernetes中 275
13.2.1  构建容器镜像 276
13.2.2  集群与Kubernetes 278
13.2.3  Kubernetes的部署描述文件 280
13.3  Kubernetes中的一等公民 284
13.3.1  健康检查 284
13.3.2  数据指标 288
13.4  是结束也是开始 291
13.5  本章小结 291



